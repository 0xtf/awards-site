import{BufferAttribute as t,BufferGeometry as e,Float32BufferAttribute as r,InstancedBufferAttribute as o,InterleavedBuffer as n,InterleavedBufferAttribute as i,TriangleFanDrawMode as s,TriangleStripDrawMode as u,TrianglesDrawMode as a,Vector3 as l}from"three";function f(e,r,o=!0){if(!r||!r.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!e.hasAttribute("position")||!e.hasAttribute("normal")||!e.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function n(t){if(t.normalized||t.isInterleavedBufferAttribute){const e=new Float32Array(t.count*t.itemSize);for(let r=0,o=0;r<t.count;r++)e[o++]=t.getX(r),e[o++]=t.getY(r),t.itemSize>2&&(e[o++]=t.getZ(r));return e}return t.array instanceof Float32Array?t.array:new Float32Array(t.array)}const i=e.index?e.toNonIndexed():e,s=r.generateTangents(n(i.attributes.position),n(i.attributes.normal),n(i.attributes.uv));if(o)for(let t=3;t<s.length;t+=4)s[t]*=-1;return i.setAttribute("tangent",new t(s,4)),e!==i&&e.copy(i),e}function c(t,r=!1){const o=null!==t[0].index,n=new Set(Object.keys(t[0].attributes)),i=new Set(Object.keys(t[0].morphAttributes)),s={},u={},a=t[0].morphTargetsRelative,l=new e;let f=0;for(let e=0;e<t.length;++e){const c=t[e];let m=0;if(o!==(null!==c.index))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in c.attributes){if(!n.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===s[t]&&(s[t]=[]),s[t].push(c.attributes[t]),m++}if(m!==n.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(a!==c.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in c.morphAttributes){if(!i.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===u[t]&&(u[t]=[]),u[t].push(c.morphAttributes[t])}if(r){let t;if(o)t=c.index.count;else{if(void 0===c.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;t=c.attributes.position.count}l.addGroup(f,t,e),f+=t}}if(o){let e=0;const r=[];for(let o=0;o<t.length;++o){const n=t[o].index;for(let t=0;t<n.count;++t)r.push(n.getX(t)+e);e+=t[o].attributes.position.count}l.setIndex(r)}for(const t in s){const e=m(s[t]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" attribute."),null;l.setAttribute(t,e)}for(const t in u){const e=u[t][0].length;if(0===e)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[t]=[];for(let r=0;r<e;++r){const e=[];for(let o=0;o<u[t].length;++o)e.push(u[t][o][r]);const o=m(e);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+t+" morphAttribute."),null;l.morphAttributes[t].push(o)}}return l}function m(e){let r,o,n,i=0;for(let t=0;t<e.length;++t){const s=e[t];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===r&&(r=s.array.constructor),r!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===o&&(o=s.itemSize),o!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===n&&(n=s.normalized),n!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;i+=s.array.length}const s=new r(i);let u=0;for(let t=0;t<e.length;++t)s.set(e[t].array,u),u+=e[t].array.length;return new t(s,o,n)}export function deepCloneAttribute(e){return e.isInstancedInterleavedBufferAttribute||e.isInterleavedBufferAttribute?deinterleaveAttribute(e):e.isInstancedBufferAttribute?(new o).copy(e):(new t).copy(e)}function g(t){let e,r=0,o=0;for(let n=0,i=t.length;n<i;++n){const i=t[n];if(void 0===e&&(e=i.array.constructor),e!==i.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;r+=i.array.length,o+=i.itemSize}const s=new n(new e(r),o);let u=0;const a=[],l=["getX","getY","getZ","getW"],f=["setX","setY","setZ","setW"];for(let e=0,r=t.length;e<r;e++){const r=t[e],o=r.itemSize,n=r.count,c=new i(s,o,u,r.normalized);a.push(c),u+=o;for(let t=0;t<n;t++)for(let e=0;e<o;e++)c[f[e]](t,r[l[e]](t))}return a}export function deinterleaveAttribute(e){const r=e.data.array.constructor,n=e.count,i=e.itemSize,s=e.normalized,u=new r(n*i);let a;a=e.isInstancedInterleavedBufferAttribute?new o(u,i,s,e.meshPerAttribute):new t(u,i,s);for(let t=0;t<n;t++)a.setX(t,e.getX(t)),i>=2&&a.setY(t,e.getY(t)),i>=3&&a.setZ(t,e.getZ(t)),i>=4&&a.setW(t,e.getW(t));return a}export function deinterleaveGeometry(t){const e=t.attributes,r=t.morphTargets,o=new Map;for(const t in e){const r=e[t];r.isInterleavedBufferAttribute&&(o.has(r)||o.set(r,deinterleaveAttribute(r)),e[t]=o.get(r))}for(const t in r){const e=r[t];e.isInterleavedBufferAttribute&&(o.has(e)||o.set(e,deinterleaveAttribute(e)),r[t]=o.get(e))}}function d(t){let e=0;for(const r in t.attributes){const o=t.getAttribute(r);e+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}const r=t.getIndex();return e+=r?r.count*r.itemSize*r.array.BYTES_PER_ELEMENT:0,e}function h(e,r=1e-4){r=Math.max(r,Number.EPSILON);const o={},n=e.getIndex(),i=e.getAttribute("position"),s=n?n.count:i.count;let u=0;const a=Object.keys(e.attributes),l={},f={},c=[],m=["getX","getY","getZ","getW"],g=["setX","setY","setZ","setW"];for(let r=0,o=a.length;r<o;r++){const o=a[r],n=e.attributes[o];l[o]=new t(new n.array.constructor(n.count*n.itemSize),n.itemSize,n.normalized);const i=e.morphAttributes[o];i&&(f[o]=new t(new i.array.constructor(i.count*i.itemSize),i.itemSize,i.normalized))}const d=Math.log10(1/r),h=Math.pow(10,d);for(let t=0;t<s;t++){const r=n?n.getX(t):t;let i="";for(let t=0,o=a.length;t<o;t++){const o=a[t],n=e.getAttribute(o),s=n.itemSize;for(let t=0;t<s;t++)i+=~~(n[m[t]](r)*h)+","}if(i in o)c.push(o[i]);else{for(let t=0,o=a.length;t<o;t++){const o=a[t],n=e.getAttribute(o),i=e.morphAttributes[o],s=n.itemSize,c=l[o],d=f[o];for(let t=0;t<s;t++){const e=m[t],o=g[t];if(c[o](u,n[e](r)),i)for(let t=0,n=i.length;t<n;t++)d[t][o](u,i[t][e](r))}}o[i]=u,c.push(u),u++}}const b=e.clone();for(const r in e.attributes){const e=l[r];if(b.setAttribute(r,new t(e.array.slice(0,u*e.itemSize),e.itemSize,e.normalized)),r in f)for(let e=0;e<f[r].length;e++){const o=f[r][e];b.morphAttributes[r][e]=new t(o.array.slice(0,u*o.itemSize),o.itemSize,o.normalized)}}return b.setIndex(c),b}function b(t,e){if(e===a)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(e===s||e===u){let r=t.getIndex();if(null===r){const e=[],o=t.getAttribute("position");if(void 0===o)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t;for(let t=0;t<o.count;t++)e.push(t);t.setIndex(e),r=t.getIndex()}const o=r.count-2,n=[];if(e===s)for(let t=1;t<=o;t++)n.push(r.getX(0)),n.push(r.getX(t)),n.push(r.getX(t+1));else for(let t=0;t<o;t++)t%2==0?(n.push(r.getX(t)),n.push(r.getX(t+1)),n.push(r.getX(t+2))):(n.push(r.getX(t+2)),n.push(r.getX(t+1)),n.push(r.getX(t)));n.length/3!==o&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=t.clone();return i.setIndex(n),i.clearGroups(),i}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}function p(t){const e=new l,o=new l,n=new l,i=new l,s=new l,u=new l,a=new l,f=new l,c=new l;function m(t,r,l,m,g,d,h,b){e.fromBufferAttribute(r,g),o.fromBufferAttribute(r,d),n.fromBufferAttribute(r,h);const p=t.morphTargetInfluences;if(l&&p){a.set(0,0,0),f.set(0,0,0),c.set(0,0,0);for(let t=0,r=l.length;t<r;t++){const r=p[t],b=l[t];0!==r&&(i.fromBufferAttribute(b,g),s.fromBufferAttribute(b,d),u.fromBufferAttribute(b,h),m?(a.addScaledVector(i,r),f.addScaledVector(s,r),c.addScaledVector(u,r)):(a.addScaledVector(i.sub(e),r),f.addScaledVector(s.sub(o),r),c.addScaledVector(u.sub(n),r)))}e.add(a),o.add(f),n.add(c)}t.isSkinnedMesh&&(t.applyBoneTransform(g,e),t.applyBoneTransform(d,o),t.applyBoneTransform(h,n)),b[3*g+0]=e.x,b[3*g+1]=e.y,b[3*g+2]=e.z,b[3*d+0]=o.x,b[3*d+1]=o.y,b[3*d+2]=o.z,b[3*h+0]=n.x,b[3*h+1]=n.y,b[3*h+2]=n.z}const g=t.geometry,d=t.material;let h,b,p;const y=g.index,A=g.attributes.position,w=g.morphAttributes.position,B=g.morphTargetsRelative,E=g.attributes.normal,x=g.morphAttributes.position,z=g.groups,T=g.drawRange;let G,I,S,v,R,X,U;const M=new Float32Array(A.count*A.itemSize),H=new Float32Array(E.count*E.itemSize);if(null!==y)if(Array.isArray(d))for(G=0,S=z.length;G<S;G++)for(R=z[G],X=Math.max(R.start,T.start),U=Math.min(R.start+R.count,T.start+T.count),I=X,v=U;I<v;I+=3)h=y.getX(I),b=y.getX(I+1),p=y.getX(I+2),m(t,A,w,B,h,b,p,M),m(t,E,x,B,h,b,p,H);else for(X=Math.max(0,T.start),U=Math.min(y.count,T.start+T.count),G=X,S=U;G<S;G+=3)h=y.getX(G),b=y.getX(G+1),p=y.getX(G+2),m(t,A,w,B,h,b,p,M),m(t,E,x,B,h,b,p,H);else if(Array.isArray(d))for(G=0,S=z.length;G<S;G++)for(R=z[G],X=Math.max(R.start,T.start),U=Math.min(R.start+R.count,T.start+T.count),I=X,v=U;I<v;I+=3)h=I,b=I+1,p=I+2,m(t,A,w,B,h,b,p,M),m(t,E,x,B,h,b,p,H);else for(X=Math.max(0,T.start),U=Math.min(A.count,T.start+T.count),G=X,S=U;G<S;G+=3)h=G,b=G+1,p=G+2,m(t,A,w,B,h,b,p,M),m(t,E,x,B,h,b,p,H);return{positionAttribute:A,normalAttribute:E,morphedPositionAttribute:new r(M,3),morphedNormalAttribute:new r(H,3)}}function y(t){if(0===t.groups.length)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),t;let e=t.groups;if(e=e.sort(((t,e)=>t.materialIndex!==e.materialIndex?t.materialIndex-e.materialIndex:t.start-e.start)),null===t.getIndex()){const e=t.getAttribute("position"),r=[];for(let t=0;t<e.count;t+=3)r.push(t,t+1,t+2);t.setIndex(r)}const r=t.getIndex(),o=[];for(let t=0;t<e.length;t++){const n=e[t],i=n.start,s=i+n.count;for(let t=i;t<s;t++)o.push(r.getX(t))}t.dispose(),t.setIndex(o);let n=0;for(let t=0;t<e.length;t++){const r=e[t];r.start=n,n+=r.count}let i=e[0];t.groups=[i];for(let r=1;r<e.length;r++){const o=e[r];i.materialIndex===o.materialIndex?i.count+=o.count:(i=o,t.groups.push(i))}return t}function A(e,r=Math.PI/3){const o=Math.cos(r),n=100*(1+1e-10),i=[new l,new l,new l],s=new l,u=new l,a=new l,f=new l;function c(t){return`${~~(t.x*n)},${~~(t.y*n)},${~~(t.z*n)}`}const m=e.toNonIndexed(),g=m.attributes.position,d={};for(let t=0,e=g.count/3;t<e;t++){const e=3*t,r=i[0].fromBufferAttribute(g,e+0),o=i[1].fromBufferAttribute(g,e+1),n=i[2].fromBufferAttribute(g,e+2);s.subVectors(n,o),u.subVectors(r,o);const a=(new l).crossVectors(s,u).normalize();for(let t=0;t<3;t++){const e=c(i[t]);e in d||(d[e]=[]),d[e].push(a)}}const h=new Float32Array(3*g.count),b=new t(h,3,!1);for(let t=0,e=g.count/3;t<e;t++){const e=3*t,r=i[0].fromBufferAttribute(g,e+0),n=i[1].fromBufferAttribute(g,e+1),l=i[2].fromBufferAttribute(g,e+2);s.subVectors(l,n),u.subVectors(r,n),a.crossVectors(s,u).normalize();for(let t=0;t<3;t++){const r=d[c(i[t])];f.set(0,0,0);for(let t=0,e=r.length;t<e;t++){const e=r[t];a.dot(e)>o&&f.add(e)}f.normalize(),b.setXYZ(e+t,f.x,f.y,f.z)}}return m.setAttribute("normal",b),m}function w(t,e=!1){return console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."),c(t,e)}function B(t){return console.warn("THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes()."),m(t)}export{f as computeMikkTSpaceTangents,c as mergeGeometries,w as mergeBufferGeometries,m as mergeAttributes,B as mergeBufferAttributes,g as interleaveAttributes,d as estimateBytesUsed,h as mergeVertices,b as toTrianglesDrawMode,p as computeMorphedAttributes,y as mergeGroups,A as toCreasedNormals};